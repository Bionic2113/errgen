package generator

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/printer"
	"go/token"
	"html/template"
	"os"
	"path/filepath"
	"strings"

	"github.com/Bionic2113/errgen/pkg/utils"
	"github.com/dave/dst"
)

const tmplt = `// Code generated by errgen. DO NOT EDIT.
	package {{.Package}}

import (
	{{range $k, $val := .Imports}} {{$val.Alias}} "{{$val.Path}}"
{{end}})
{{range .Functions}}

type {{.FunctionName}}Error struct {
	{{- range .Args}}
	{{.Name}} {{.Type}}
	{{- end}}
	%[1]s string
	%[2]s    error
}

func New{{.FunctionName}}Error({{range .Args}}{{.Name}} {{.Type}}, {{end}}%[1]s string, %[2]s error) *{{.FunctionName}}Error {
	return &{{.FunctionName}}Error{
		{{- range .Args}}
		{{.Name}}: {{.Name}},
		{{- end}}
		%[1]s: %[1]s,
		%[2]s: %[2]s,
	}
}

func (e *{{.FunctionName}}Error) Error() string {
	return "[" + {{if .SubPackageName}}"{{.SubPackageName}}/" +{{end}}"{{.PackageName}}" + {{if .ReceiverType}}".{{.ReceiverType}}" +{{end}}"] - " +
		"{{.FunctionName}} - " + e.%[1]s +
		{{if .Args}}" - args: {" + {{/* start range */}}{{range $i, $arg := .Args}}{{if $i}} + ", " +{{end}}
		"{{.Name}}: " + {{if eq .Type "string"}}e.{{.Name}}{{else if eq .Type "int"}}strconv.Itoa(e.{{.Name}}){{else if eq .Type "int64"}}strconv.FormatInt(e.{{.Name}}, 10){{else if eq .Type "uint64"}}strconv.FormatUint(e.{{.Name}}, 10){{else if eq .Type "float64"}}strconv.FormatFloat(e.{{.Name}}, 'f', -1, 64){{else if eq .Type "bool"}}strconv.FormatBool(e.{{.Name}}){{else}}fmt.Sprintf("%[3]s", e.{{.Name}}){{end}}{{end}} +
		"}" +{{end}}{{/* end range */}} "\n" +
		e.%[2]s.Error()
}

func (e *{{.FunctionName}}Error) Unwrap() error {
	return e.%[2]s
}

func (e *{{.FunctionName}}Error) Is(target error) bool {
	if _, ok := target.(*{{.FunctionName}}Error); ok {
		return true
	}
	return errors.Is(e.%[2]s, target)
}
{{end}}`

type ErrorInformator interface {
	ErrorName(pkgInfo utils.PkgInfo, errText string) string
}

func AnalyzeFunctions(
	node *dst.File,
	pkgInfo utils.PkgInfo,
	subPkg, currentDir, fileName string,
	errInformator ErrorInformator,
	skipper utils.Skipper,
) []utils.FunctionInfo {
	var functions []utils.FunctionInfo
	imports := utils.CollectImports(node)
	originalPath := filepath.Join(currentDir, subPkg, fileName)

	dst.Inspect(node, func(n dst.Node) bool {
		if funcDecl, ok := n.(*dst.FuncDecl); ok && HasErrorReturn(funcDecl) {
			f := utils.CreateFunctionInfo(funcDecl, pkgInfo, subPkg, imports, skipper)
			functions = append(functions, f)
			ModifyFunctionBody(funcDecl, f, pkgInfo, errInformator)

		}
		return true
	})

	if len(functions) > 0 {
		utils.RemoveUnusedImports(node)
		utils.WriteModifiedFile(node, originalPath)
	}

	return functions
}

func HasErrorReturn(funcDecl *dst.FuncDecl) bool {
	if funcDecl.Type.Results == nil {
		return false
	}

	for _, result := range funcDecl.Type.Results.List {
		if ident, ok := result.Type.(*dst.Ident); ok {
			if ident.Name == "error" {
				return true
			}
		}
	}

	return false
}

func ErrorReturnIndex(funcNode dst.Node) int {
	funcLit := &dst.FuncLit{}
	switch val := funcNode.(type) {
	default:
		return -1
	case *dst.FuncLit:
		funcLit.Type = val.Type
	case *dst.FuncDecl:
		funcLit.Type = val.Type
	}

	if funcLit.Type.Results == nil {
		return -1
	}

	var totalIndex int
	for _, field := range funcLit.Type.Results.List {
		if ident, ok := field.Type.(*dst.Ident); ok {
			if ident.Name == "error" {
				return totalIndex
			}
		}

		// for someFoo() (arg1, arg2 int, err error)
		add := len(field.Names)
		if add == 0 {
			add = 1
		}

		totalIndex += add
	}
	return -1
}

func GenerateErrorFile(filename string, pkgInfo utils.PkgInfo, functions []utils.FunctionInfo) {
	imports := map[string]utils.Path{"errors": {Path: "errors"}}
	for _, f := range functions {
		for _, arg := range f.Args {

			switch {
			case strings.HasPrefix(arg.Type, "time."):
				imports["time"] = utils.Path{Path: "time"}

			case arg.Type == "int" || arg.Type == "int64" || arg.Type == "uint64":
				imports["strconv"] = utils.Path{Path: "strconv"}
			case arg.Type == "float64":
				imports["strconv"] = utils.Path{Path: "strconv"}

			case arg.Type == "bool":
				imports["strconv"] = utils.Path{Path: "strconv"}
			case arg.Type == "any" || strings.Contains(arg.Type, "[]"):
				imports["fmt"] = utils.Path{Path: "fmt"}
			case !utils.IsBasicType(arg.Type):
				imports["fmt"] = utils.Path{Path: "fmt"}
			}
			if strings.Contains(arg.Type, ".") {
				parts := strings.SplitN(arg.Type, ".", 2)
				if len(parts) == 2 {
					pkgName := strings.TrimPrefix(strings.TrimPrefix(parts[0], "[]"), "*")
					if importPath, ok := f.Imports[pkgName]; ok {
						imports[pkgName] = importPath
					}
				}
			}
		}
	}

	templateData := ErrorTemplate{Package: pkgInfo.Name, Functions: functions}
	errGenName, reasonErrGen := "errErrGen", "reasonErrGen"

	tmpl := fmt.Sprintf(tmplt, reasonErrGen, errGenName, "%#v")

	data := struct {
		Package   string
		Functions []utils.FunctionInfo
		Imports   map[string]utils.Path
	}{Package: templateData.Package, Functions: templateData.Functions, Imports: imports}

	errFilePath := filepath.Join(pkgInfo.Path, filename+".go")

	f, err := os.Create(errFilePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	t, err := template.New("errors").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	formattedBuf := &bytes.Buffer{}
	if err := t.Execute(formattedBuf, data); err != nil {
		panic(err)
	}

	cfg := printer.Config{Mode: printer.UseSpaces | printer.TabIndent, Tabwidth: 8}

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", formattedBuf.String(), parser.ParseComments)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	if err := cfg.Fprint(&buf, fset, astFile); err != nil {
		panic(err)
	}

	if err := os.WriteFile(errFilePath, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

func ModifyFunctionBody(
	funcDecl *dst.FuncDecl,
	info utils.FunctionInfo,
	pkgInfo utils.PkgInfo,
	errInformator ErrorInformator,
) {
	parentMap := make(map[dst.Node]dst.Node)
	dst.Inspect(funcDecl.Body, func(n dst.Node) bool {
		if n == nil {
			return false
		}

		dst.Inspect(n, func(child dst.Node) bool {
			if child == nil {
				return false
			}
			if child != n {
				parentMap[child] = n
			}

			return true
		})

		return true
	})

	errorIndex := ErrorReturnIndex(funcDecl)
	if errorIndex == -1 {
		return
	}

	dst.Inspect(funcDecl.Body, func(n dst.Node) bool {
		// For anonymous functions
		// TODO: need refactor
		errorIndex = func() int {
			funcLit, ok := n.(*dst.FuncLit)
			if !ok {
				return errorIndex
			}
			return ErrorReturnIndex(funcLit)
		}()
		if errorIndex == -1 {
			return false
		}

		returnStmt, ok := n.(*dst.ReturnStmt)
		if !ok || errorIndex >= len(returnStmt.Results) {
			return true
		}

		result := returnStmt.Results[errorIndex]
		if IsNilError(result) {
			return true
		}

		if !IsNeedChange(result) {
			return true
		}

		// Определяем сообщение об ошибке и нужно ли использовать nil
		reason := "unknown error in " + info.FunctionName

		// Проверяем не создается ли ошибка напрямую
		msg, ok, useNilError := ExtractErrorMessage(result)
		if !ok {
			// Проверяем, не является ли ошибка результатом вызова функции
			var funcLit bool
			msg, ok, funcLit = FindLastFunctionCall(returnStmt, parentMap)
			if funcLit {
				return true
			}
		}

		if msg != "" {
			reason = msg
		}

		errArg := IsErrorWrapper(result)
		if errArg == nil {
			errArg = result
			if useNilError {
				errArg = dst.NewIdent(errInformator.ErrorName(pkgInfo, reason))
				reason = "unknown error in " + info.FunctionName
			}
		}

		constructorCall := &dst.CallExpr{
			Fun: dst.NewIdent("New" + info.FunctionName + "Error"),
			Args: append(
				utils.ArgumentNames(funcDecl, info.Args),
				dst.NewIdent("\""+reason+"\""),
				errArg,
			),
		}
		returnStmt.Results[errorIndex] = constructorCall

		return true
	})
}

func IsNilError(expr dst.Expr) bool {
	if ident, ok := expr.(*dst.Ident); ok {
		return ident.Name == "nil"
	}

	return false
}

// Проверяем нужно ли нам заменить возврат ошибки
// на обертку
func IsNeedChange(expr dst.Expr) bool {
	call, ok := expr.(*dst.CallExpr)
	if !ok {
		return true
	}

	// Если не наша обертка, то пропускаем
	if ident, ok := call.Fun.(*dst.Ident); ok {
		return !strings.HasSuffix(ident.Name, "Error")
	}

	// Если эти функции - это создание через fmt или errors,
	// то обрабатываем
	if selector, ok := call.Fun.(*dst.SelectorExpr); ok {
		if ident, ok := selector.X.(*dst.Ident); ok {
			return ident.Name == "fmt" || ident.Name == "errors"
		}
	}

	return false
}

func IsErrorWrapper(expr dst.Expr) dst.Expr {
	if callExpr, ok := expr.(*dst.CallExpr); ok {
		if ident, ok := callExpr.Fun.(*dst.Ident); ok {
			if strings.HasSuffix(ident.Name, "Error") {
				return callExpr.Args[len(callExpr.Args)-1]
			}
		}
	}

	return nil
}

func ExtractErrorMessage(expr dst.Expr) (string, bool, bool) {
	callExpr, ok := expr.(*dst.CallExpr)
	if !ok {
		return "", false, false
	}

	switch v := callExpr.Fun.(type) {
	default:
		return "", false, false
	case *dst.Ident:
		// Если уже была обертка, то забираем причину
		if strings.HasSuffix(v.Name, "Error") && len(callExpr.Args) > 1 {
			if lit, ok := callExpr.Args[len(callExpr.Args)-2].(*dst.BasicLit); ok {
				return strings.Trim(lit.Value, `"`), true, false
			}
		}

		return v.Name, true, false
	case *dst.SelectorExpr:
		ident, ok := v.X.(*dst.Ident)
		if !ok {
			return v.Sel.Name, true, false
		}

		if (ident.Name == "errors" && v.Sel.Name == "New") || (ident.Name == "fmt" && (v.Sel.Name == "Errorf")) {
			if len(callExpr.Args) > 0 {
				if lit, ok := callExpr.Args[0].(*dst.BasicLit); ok {
					return strings.Trim(lit.Value, `"`), true, true
				}

				var buf bytes.Buffer
				printer.Fprint(&buf, token.NewFileSet(), callExpr.Args[0])

				return buf.String(), true, true
			}
		}

		return ident.Name + "." + v.Sel.Name, true, false
	}
}

func FindLastFunctionCall(node dst.Node, parentMap map[dst.Node]dst.Node) (string, bool, bool) {
	parent := parentMap[node]
	for parent != nil {
		var assignStmt *dst.AssignStmt
		switch stmt := parent.(type) {
		default:
			parent = parentMap[parent]
			continue
		case *dst.FuncLit:
			return "", false, true
		case *dst.AssignStmt:
			assignStmt = stmt
		case *dst.IfStmt:
			a, ok := stmt.Init.(*dst.AssignStmt)
			if ok {
				assignStmt = a
				break // switch
			}
			p := parentMap[stmt]
			b, ok := p.(*dst.BlockStmt)
			if !ok {
				parent = parentMap[parent]
				continue
			}
			for i, v := range b.List[1:] {
				if v != stmt {
					continue
				}
				if a, ok := b.List[i].(*dst.AssignStmt); ok {
					assignStmt = a
					break
				}
			}
			if assignStmt == nil {
				parent = parentMap[parent]
				continue
			}
		case *dst.BlockStmt:
			assignStmt = BlockStmt(stmt)
			if assignStmt == nil {
				parent = parentMap[parent]
				continue
			}

		}

		rhs := Rhs(assignStmt, func() { parent = parentMap[parent] })
		if rhs == nil {
			continue
		}

		return Reason(rhs), true, false
	}

	return "", false, false
}

func Reason(expr dst.Expr) string {
	switch v := expr.(type) {
	default:
		fmt.Printf("reason default: %#v\n", v)
		return ""
	case *dst.CallExpr:
		return Reason(v.Fun)
	case *dst.Ident:
		return v.Name
	case *dst.SelectorExpr:
		return Reason(v.X) + "." + v.Sel.Name
	case *dst.StarExpr:
		return Reason(v.X)
	case *dst.IndexExpr:
		return Reason(v.X)
	case *dst.TypeAssertExpr:
		return Reason(v.X)
	case *dst.CompositeLit:
		return Reason(v.Type)
	case *dst.ParenExpr:
		return Reason(v.X)
	case *dst.UnaryExpr:
		return Reason(v.X)
	case *dst.ArrayType:
		return Reason(v.Elt)
	}
}

func BlockStmt(stmt *dst.BlockStmt) *dst.AssignStmt {
	for i := len(stmt.List) - 1; i >= 0; i-- {
		assignStmt, ok := stmt.List[i].(*dst.AssignStmt)
		if !ok {
			continue
		}
		rhs := Rhs(assignStmt, nil)
		if rhs == nil {
			continue
		}
		// Здесь пропускаем errors.Join, тк странно такую причину указывать.
		// Поищем повыше
		if call, ok := rhs.(*dst.CallExpr); ok {
			if f, ok := call.Fun.(*dst.SelectorExpr); ok {
				if f.Sel.Name == "errors" {
					if ident, ok := f.X.(*dst.Ident); ok && ident.Name == "Join" {
						continue
					}
				}
			}
		}

		return assignStmt
	}

	return nil
}

func Rhs(assignStmt *dst.AssignStmt, changeParent func()) dst.Expr {
	index := -1
	for i, field := range assignStmt.Lhs {
		f, ok := field.(*dst.Ident)
		if !ok {
			continue
		}

		if strings.HasPrefix(f.Name, "err") ||
			strings.HasSuffix(f.Name, "err") ||
			strings.HasSuffix(f.Name, "Err") {
			index = i
			break
		}
	}

	if index < 0 {
		if changeParent != nil {
			changeParent()
		}

		return nil
	}

	rhs := assignStmt.Rhs[0]
	if len(assignStmt.Rhs) > 1 {
		rhs = assignStmt.Rhs[index]
	}

	return rhs
}
